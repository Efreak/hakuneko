<link rel="import" href="invalid.html">

<script>

    /**
     * System
     * A special connector to show all bookmarked mangas from various connectors.
     * This connector does not implement the connector base class, because it operates different.
     */
    class BookmarkConnector {

        /**
         *
         */
        constructor() {
            // Public members for usage in UI (mandatory)
            this.id       = 'bookmarks';
            this.label    = ' 【Bookmarks】';
            this.icon     = '/img/connectors/' + this.id;
            this.tags     = [ /* 'bookmarks', 'favorites' */ ];
            this.isLocked = false;
            // Private members for internal usage only (convenience)
            this.url      = undefined;
            this.referer  = undefined;
            this.agent    = undefined;
            // Private members for internal use that can be configured by the user through settings menu (set to undefined or false to hide from settings menu!)
            this.config = undefined;
        }

        /**
         *
         */
        _getConnectorByID( id ) {
            return Engine.Connectors.find( connector => {
                return ( connector.id === id );
            } ) || new InvalidConnector( id, `${id} (unavailable)` );
        }

        /**
         *
         */
        _createMangaFromBookmark( bookmark ) {
            return new Manga( this._getConnectorByID( bookmark.key.connector ), bookmark.key.manga, bookmark.title.manga );
        }

        /**
         *
         */
        updateMangas( callback ) {
            if( confirm( 'Check for new chapters?\n\nThis may take a while and HakuNeko cannot be used until the operation is finished (or aborted)!' ) ) {
                // get chapter list for bookmark
                // wait for error or success
                // determine which chapters are not yet known (new)
                // add result to result list
                // process next bookmark
                let node = {
                    current: undefined,
                    next: undefined
                };
                let firstNode = node;
                for(let bookmark of Engine.BookmarkManager.bookmarks) {
                    let manga = this._createMangaFromBookmark( bookmark );
                    let knownChapters = bookmark.knownChapters;
                    
                    console.log( manga.connector.label, manga.title, '=>', bookmark.knownChapters.length );
                }
            }
            this._getMangaList( callback );
        }

        /**
         *
         */
        getMangas( callback ) {
            this._getMangaList( callback );
        }

        /**
         *
         */
        _getMangaList( callback ) {
            // get mangas and check status
            // use a different approach to determine existence of manga, since it can be expected that
            // the bookmark list is way shorter than a manga list of a connector => no performance issues expected
            let mangas = Engine.BookmarkManager.bookmarks.map( bookmark => {
                let manga = this._createMangaFromBookmark( bookmark );
                // determine if manga directory exist on disk
                Engine.Storage.mangaDirectoryExist( manga )
                .then( () => {
                    // set existing manga list for related connector (used by manga.updateStatus function)
                    manga.connector.existingMangas[ Engine.Storage.sanatizePath ( manga.title ) ] = true;
                    manga.updateStatus();
                } )
                .catch( error => { /* directory for bookmark does not yet exist */ } );
                return manga;
            });
            mangas.sort( ( a, b ) => {
                return ( a.title.toLowerCase() < b.title.toLowerCase() ? -1 : 1 );
            });
            callback( null, mangas );
        }
    }
    BookmarkConnector; // reference the class to prevent removal of the class through js-minify

</script>