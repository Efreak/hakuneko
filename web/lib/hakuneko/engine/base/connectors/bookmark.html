<link rel="import" href="invalid.html">

<script>

    /**
     * System
     * A special connector to show all bookmarked mangas from various connectors.
     * This connector does not implement the connector base class, because it operates different.
     */
    class BookmarkConnector {

        /**
         *
         */
        constructor() {
            // Public members for usage in UI (mandatory)
            this.id       = 'bookmarks';
            this.label    = ' 【Bookmarks】';
            this.icon     = '/img/connectors/' + this.id;
            this.tags     = [ /* 'bookmarks', 'favorites' */ ];
            this.isLocked = false;
            // Private members for internal usage only (convenience)
            this.url      = undefined;
            this.referer  = undefined;
            this.agent    = undefined;
            // Private members for internal use that can be configured by the user through settings menu (set to undefined or false to hide from settings menu!)
            this.config = undefined;
        }

        /**
         *
         */
        _getConnectorByID( id ) {
            return Engine.Connectors.find( connector => {
                return ( connector.id === id );
            } ) || new InvalidConnector( id, `${id} (unavailable)` );
        }

        /**
         *
         */
        _createMangaFromBookmark( bookmark ) {
            return new Manga( this._getConnectorByID( bookmark.key.connector ), bookmark.key.manga, bookmark.title.manga );
        }

        /**
         *
         */
        _getNewChapters( bookmarks, index ) {
            index = index || 0;
            return new Promise( ( resolve, reject ) => {
                let bookmark = bookmarks[index];
                let result = {
                    manga: this._createMangaFromBookmark( bookmark ),
                    chapters: []
                };
                // get known chapters before they are updated by Manga.getChapters(...)
                let knownChapters = bookmark.knownChapters;
                result.manga.getChapters( ( error, latestChapters ) => {
                    try {
                        if( error ) {
                            throw error;
                        }
                        result.chapters = latestChapters.filter( chapter => chapter.status === DownloadStatus.available && !knownChapters.includes( chapter.id ) );
                        resolve( result );
                    } catch( err ) {
                        reject( err );
                    }
                } );
            } )
            .catch( error => Promise.resolve( error ) )
            .then( result => {
                if( index < bookmarks.length - 1 ) {
                    return this._getNewChapters( bookmarks, index + 1 )
                    .then( results => [ result ].concat( results ) );
                } else {
                    return Promise.resolve( [ result ] );
                }
            } );
        }

        /**
         *
         */
         _showReport( updateResults ) {
            let dataURL = `data:text/html;utf8,<!DOCTYPE html>
            <html>
            <head>
                <meta charset="utf-8">
            </head>
            <body>
                <h1>Bookmark Update Results</h1>
                <div>
                    This list shows all chapters that have been added since you last visited the chapter list
                    and are not already downloaded.
                </div>
                <div>${ updateResults.map( result => {
                    if( result instanceof Error ) {
                        return result.message;
                    } else {
                        return result.manga.title + ': <ul>' + result.chapters.map( chapter => '<li>' + chapter.title + '</li>' ).join( '' ) + '</ul>';
                    }
                } ).join( ',<br>' ) }</div>
                <table style="font-family: monospace;">
                    <tbody style="color: blue;">
                    <tr>
                        <th colspan="2" style="font-size: 1.5em; font-weight: bold; text-align: left;">
                            <hr><a name="exists">EXISTING BOOKMARKS</a><hr>
                        </th>
                    </tr>
                    </tbody>
                </table>
            </body>
            </html>`;
            window.open( dataURL, '_blank', 'title=Boomkmark Update Results,center=true,width=800,height=600' );
        }

        /**
         *
         */
        updateMangas( callback ) {
            if( confirm( 'Check for new chapters?\n\nThis may take a while and HakuNeko cannot be used until the operation is finished (or aborted)!' ) ) {
                // NOTE: currently VRV and 9anime are excluded because of slow speed
                this._getNewChapters( Engine.BookmarkManager.bookmarks.filter( bookmark => !bookmark.archived ).filter( bookmark => !bookmark.key.connector.startsWith( 'vrv' ) && bookmark.key.connector !== '9anime' ) )
                .then( results => {
                    console.log( 'Boomkmark Update Results:', results );
                    this._showReport( results );
                } )
                .catch( error => {
                    console.error( 'Boomkmark Update Results:', error );
                } );
            }
            this._getMangaList( callback );
        }

        /**
         *
         */
        getMangas( callback ) {
            this._getMangaList( callback );
        }

        /**
         *
         */
        _getMangaList( callback ) {
            // get mangas and check status
            // use a different approach to determine existence of manga, since it can be expected that
            // the bookmark list is way shorter than a manga list of a connector => no performance issues expected
            let mangas = Engine.BookmarkManager.bookmarks.map( bookmark => {
                let manga = this._createMangaFromBookmark( bookmark );
                // determine if manga directory exist on disk
                Engine.Storage.mangaDirectoryExist( manga )
                .then( () => {
                    // set existing manga list for related connector (used by manga.updateStatus function)
                    manga.connector.existingMangas[ Engine.Storage.sanatizePath ( manga.title ) ] = true;
                    manga.updateStatus();
                } )
                .catch( error => { /* directory for bookmark does not yet exist */ } );
                return manga;
            });
            mangas.sort( ( a, b ) => {
                return ( a.title.toLowerCase() < b.title.toLowerCase() ? -1 : 1 );
            });
            callback( null, mangas );
        }
    }
    BookmarkConnector; // reference the class to prevent removal of the class through js-minify

</script>